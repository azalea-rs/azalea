from lib.utils import get_dir_location, to_camel_case


COLLISION_BLOCKS_RS_DIR = get_dir_location(
    '../azalea-physics/src/collision/blocks.rs')


def generate_block_shapes(blocks: dict, shapes: dict, block_states_report):
    code = generate_block_shapes_code(blocks, shapes, block_states_report)
    with open(COLLISION_BLOCKS_RS_DIR, 'w') as f:
        f.write(code)


def generate_block_shapes_code(blocks: dict, shapes: dict, block_states_report):
    # look at downloads/generator-mod-*/blockCollisionShapes.json for format of blocks and shapes

    generated_shape_code = ''
    for shape_id, shape in sorted(shapes.items(), key=lambda shape: int(shape[0])):
        generated_shape_code += generate_code_for_shape(shape_id, shape)

    generated_impl_code = ''
    for block_id, shape_ids in blocks.items():
        block_report_data = block_states_report['minecraft:' + block_id]
        generated_impl_code += generate_code_for_impl(
            block_id, shape_ids, block_report_data)

    return f'''
//! Autogenerated block collisions for every block

// This file is generated from codegen/lib/code/block_shapes.py. If you want to
// modify it, change that file.

#![allow(clippy::explicit_auto_deref)]

use super::VoxelShape;
use crate::collision::{{self, Shapes}};
use lazy_static::lazy_static;

trait BlockWithShape {{
    fn shape(&self) -> &'static VoxelShape;
}}

lazy_static! {{
    {generated_shape_code}
}}

{generated_impl_code}
'''


def generate_code_for_shape(shape_id: str, parts: list[list[float]]):
    def make_arguments(part: list[float]):
        return ', '.join(map(lambda n: str(n).rstrip('0'), part))
    code = ''
    code += f'static ref SHAPE{shape_id}: VoxelShape = {{\n'
    steps = []
    if parts == []:
        steps.append('collision::empty_shape()')
    else:
        steps.append(f'collision::box_shape({make_arguments(parts[0])})')
        for part in parts[1:]:
            steps.append(
                f'Shapes::or(s, collision::box_shape({make_arguments(part)}))')

    for step in steps[:-1]:
        code += f'    let s = {step};\n'
    code += f'    {steps[-1]}\n'
    code += f'}};\n'
    return code


def generate_code_for_impl(block_id: str, shape_ids: list[int], block_report_data):
    if block_id != 'spruce_fence':
        return ''

    # match self {
    #     azalea_block::StoneSlabBlock {
    #         kind: azalea_block::Type::Top,
    #         waterlogged: azalea_block::Waterlogged::True,
    #     } => &SHAPE0,
    #     _ => &SHAPE1,
    # }

    block_struct_name = to_camel_case(block_id)

    property_names = tuple(block_report_data['properties'].keys())

    # { (tuple of property values): shape_id }
    possible_states = {}
    for possible_state, shape_id in zip(block_report_data['states'], shape_ids):
        possible_states[tuple(
            possible_state['properties'].values())] = shape_id
    print(possible_states)

    match_inner = ''

    for property_values, shape_id in possible_states.items():
        match_inner += f'    {block_struct_name} {{\n'
        for property_name, property_value in zip(property_names, property_values):
            match_inner += f'        {property_name}: azalea_block::{to_camel_case(property_name)}::{to_camel_case(property_value)},\n'
        match_inner += f'    }} => &SHAPE{shape_id},\n'

    function_inner = 'match self {\n' + match_inner + '\n}'

    code = ''
    code += f'impl BlockWithShape for azalea_block::{block_struct_name} {{\n'
    code += f'    fn shape(&self) -> &\'static VoxelShape {{\n'
    code += f'        {function_inner}\n'
    code += f'    }}\n'
    code += '}'

    return code
